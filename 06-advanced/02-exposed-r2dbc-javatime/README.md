# 02 Exposed R2DBC Java Time example

This module demonstrates how to use the
`exposed-java-time` extension, which provides seamless integration with the modern Java 8
`java.time` (JSR-310) API. This is the standard and recommended way to handle date and time values in Exposed.

## Learning Objectives

- Understand how to map database date/time types to `java.time` objects like `LocalDate`, `LocalDateTime`,
  `Instant`, and `OffsetDateTime`.
- Use built-in SQL functions for date/time manipulation (e.g., `year()`, `month()`, `day()`).
- Define default values for date/time columns, including server-side defaults like `CURRENT_TIMESTAMP`.
- Correctly use date/time literals in `WHERE` clauses for comparisons.
- Be aware of the differences in date/time handling and precision across various database dialects.

## Key Column Types and Functions

The `exposed-java-time` module introduces several column types and functions to your Exposed DSL.

### Column Types

- `date(name)`: Maps to `java.time.LocalDate`.
- `time(name)`: Maps to `java.time.LocalTime`.
- `datetime(name)`: Maps to `java.time.LocalDateTime`.
- `timestamp(name)`: Maps to `java.time.Instant`.
- `timestampWithTimeZone(name)`: Maps to `java.time.OffsetDateTime`.
- `duration(name)`: Maps to `java.time.Duration`.

### Default Expressions

You can use special expressions to set server-side default values.

- `CurrentDate`: Represents the database's `CURRENT_DATE` function.
- `CurrentDateTime` / `CurrentTimestamp`: Represent the database's `CURRENT_TIMESTAMP` or equivalent function.
- `CurrentTimestampWithTimeZone`: Represents the database's `CURRENT_TIMESTAMP WITH TIME ZONE` function.

### Literals for Queries

When comparing date/time values in a
`WHERE` clause, it's best practice to use literal functions to ensure the value is formatted correctly for the specific database dialect.

- `dateLiteral(LocalDate)`
- `timeLiteral(LocalTime)`
- `dateTimeLiteral(LocalDateTime)`
- `timestampLiteral(Instant)`
- `timestampWithTimeZoneLiteral(OffsetDateTime)`

## Examples Overview

### `Ex01_JavaTime.kt` - Basic Usage and Functions

This file demonstrates core functionality, including:

- Using date part extraction functions like `year()`, `month()`, and `day()` in queries.
- Storing and retrieving `Instant` and `LocalDateTime` values, including handling of nanosecond precision.
- Working with
  `timestampWithTimeZone` and understanding how different databases handle time zone information (e.g., some convert to and store in UTC).

### `Ex02_Defaults.kt` - Default Values

This file explores how to set default values for date/time columns.

- `clientDefault { ... }`: The default value is generated by the client (your application) before the
  `INSERT` statement.
- `default(value)`: A constant default value.
- `defaultExpression(...)`: The default value is generated by the database itself, using functions like
  `CurrentDateTime`.

### `Ex03_DateTimeLiteral.kt` - Querying with Literals

This file shows the correct way to use date/time values in `WHERE` clauses. Using literal functions like
`dateLiteral()` and `dateTimeLiteral()` ensures that the comparison works correctly across different databases.

### `Ex04_MiscTable.kt` - Comprehensive Integration Test

This file contains a large table (`Misc`) with every
`java.time` column type in both nullable and non-nullable variants. It provides extensive tests for `INSERT`,
`SELECT`, and `UPDATE` operations, serving as a robust example of how these types behave in practice.

## Code Snippets

### 1. Defining a Table with `java.time` Columns

```kotlin
object CitiesTime: IntIdTable("CitiesTime") {
  val name: Column<String> = varchar("name", 50)

  // A nullable LocalDateTime column
  val local_time: Column<LocalDateTime?> = datetime("local_time").nullable()
}

object TableWithDBDefault: IntIdTable("t_db_default") {
  // A non-nullable LocalDateTime column with a server-side default
  val t1: Column<LocalDateTime> = datetime("t1").defaultExpression(CurrentDateTime)
}
```

### 2. Inserting and Querying `java.time` Values

```kotlin
// Inserting a value
val now = LocalDateTime.now()
val cityID = CitiesTime.insertAndGetId {
  it[name] = "Seoul"
  it[local_time] = now
}

// Querying using a date part function
val year = CitiesTime
  .select(CitiesTime.local_time.year())
  .where { CitiesTime.id eq cityID }
  .single()[CitiesTime.local_time.year()]

// Querying using a literal in a WHERE clause
val result = TableWithDate.selectAll()
  .where { TableWithDate.date less dateLiteral(LocalDate.of(3000, 1, 1)) }
  .firstOrNull()
```

## Test Execution

```bash
# Run all tests in this module
./gradlew :06-advanced:02-exposed-javatime:test

# Run a specific test class
./gradlew :06-advanced:02-exposed-javatime:test --tests "exposed.examples.java.time.Ex01_JavaTime"
```

## Further Reading

- [Exposed Java Time Module](https://debop.notion.site/Exposed-Java-Time-1c32744526b0809d85e1d0425038dfdd)
