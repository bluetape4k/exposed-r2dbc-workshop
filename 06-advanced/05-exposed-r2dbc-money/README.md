# 04 Exposed R2DBC Money example

This module demonstrates how to use the
`exposed-money` extension to work with monetary values in a safe and structured way. It integrates with the JavaMoney (
`javax.money`) API, which is the standard for handling money in Java and Kotlin applications. This approach avoids common pitfalls of using
`Double` or
`Float` for financial calculations and ensures that currency information is always paired with a numeric amount.

## Learning Objectives

- Define columns for storing monetary values using `compositeMoney`.
- Understand how `compositeMoney` maps a single
  `MonetaryAmount` object to separate amount and currency columns in the database.
- Insert, update, and query monetary data in both DSL and DAO styles.
- Access and query the individual components (amount and currency) of a money column.
- Set default values for money columns.

## Key Concepts

### `compositeMoney`

The core of this extension is the
`compositeMoney()` function. It's a "composite column" because it bundles multiple underlying database columns into a single, logical property in your Kotlin code.

`compositeMoney(precision: Int, scale: Int, columnName: String)`

- This function creates and manages two columns behind the scenes:
  1. A `DECIMAL` column for the `amount` (e.g., `DECIMAL(precision, scale)`).
  2. A `VARCHAR` column for the `currency` (e.g., `VARCHAR(3)`). The currency column's name is derived from the
     `columnName` by appending `_C`.
- In your code, you interact with it as a single `CompositeColumn<MonetaryAmount?>`.

### Accessing Amount and Currency

The `CompositeColumn` returned by `compositeMoney` gives you access to its constituent parts:

- `.amount`: A `Column<BigDecimal?>` representing the numeric value.
- `.currency`: A `Column<CurrencyUnit?>` representing the currency unit.

This allows for flexible queries, as you can filter by the full `MonetaryAmount`, just the amount, or just the currency.

## Examples Overview

### `MoneyData.kt` - Table and Entity Definition

This file defines the `AccountTable` and the `AccountEntity` to show the basic setup for `compositeMoney`.

- **`AccountTable`**: An `IntIdTable` with a `compositeMoney` column named `composite_money`. This will create
  `composite_money` (DECIMAL) and `composite_money_C` (VARCHAR) columns in the database.
- **`AccountEntity`**: The corresponding DAO entity. It shows how to map the composite column to a single
  `money` property of type
  `MonetaryAmount?`. It also demonstrates creating convenient delegated properties for direct access to `amount` and
  `currency`.

### `Ex01_MoneyDefaults.kt` - Default Values

This file demonstrates how to set default values for `compositeMoney` columns, using both
`.default()` for constant values and `.clientDefault()` for values generated by a lambda.

### `Ex02_Money.kt` - CRUD and Querying

This file provides comprehensive examples of working with money columns.

- **Insertion**: Shows inserting a complete `MonetaryAmount` object and also inserting by setting the `.amount` and
  `.currency` components separately.
- **Selection**: Demonstrates retrieving the `MonetaryAmount` object.
- **Querying**: Shows how to use the composite column and its components in `WHERE` clauses to find records.
- **Manual Composite Columns**: Illustrates how you can manually create a `compositeMoney` column from pre-existing
  `decimal` and `currency` columns.

## Code Snippets

### 1. Defining a Table with a Money Column

```kotlin
import org.jetbrains.exposed.v1.money.compositeMoney

internal object AccountTable: IntIdTable("Accounts") {
    // Defines a nullable money column with 8 total digits and 5 decimal places.
    // This will create two DB columns: "composite_money" and "composite_money_C".
    val composite_money = compositeMoney(8, 5, "composite_money").nullable()
}
```

### 2. Working with Money in an Entity (DAO)

```kotlin
internal class AccountEntity(id: EntityID<Int>): IntEntity(id) {
  companion object: EntityClass<Int, AccountEntity>(AccountTable)

  // The full MonetaryAmount object
  var money: MonetaryAmount? by AccountTable.composite_money

  // Direct access to the underlying amount and currency
  val amount: BigDecimal? by AccountTable.composite_money.amount
  val currency: CurrencyUnit? by AccountTable.composite_money.currency
}
```

### 3. Inserting and Querying Monetary Values (DSL)

```kotlin
import org.javamoney.moneta.Money

// Create a MonetaryAmount
val tenDollars = Money.of(10, "USD")

// Insert the full object
AccountTable.insert {
    it[composite_money] = tenDollars
}

// Or insert components separately
AccountTable.insert {
    it[composite_money.amount] = BigDecimal("10.00")
    it[composite_money.currency] = // ... get CurrencyUnit for "USD"
}

// Query by the full object
val results = AccountTable.selectAll().where { AccountTable.composite_money eq tenDollars }

// Query by just the currency
val usdAccounts = AccountTable.selectAll().where { AccountTable.composite_money.currency eq currencyUnitOf("USD") }
```

## Test Execution

```bash
# Run all tests in this module
./gradlew :06-advanced:05-exposed-money:test

# Run a specific test class
./gradlew :06-advanced:05-exposed-money:test --tests "exposed.examples.money.Ex02_Money"
```

## Further Reading

- [Exposed Money](https://debop.notion.site/Exposed-Money-1c32744526b08051a216d87ca750d73f)
